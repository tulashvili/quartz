---
title: JavaScript
draft: false
tags: 
date: 2025-02-03
updated: 2025-02-09T14:43
---
- курс - [https://www.youtube.com/watch?v=CxgOKJh4zWE](https://www.youtube.com/watch?v=CxgOKJh4zWE)
- Встроен в браузер, поэтому можно код выполнять прямо в консоли браузера:  
	![[Pasted image 20250209143806.png]]
- Помимо браузера код Javascript можно выполнять в терминале, используя nodejs  
    ![[Pasted image 20250209143841.png]]

В JS есть три ключевых темы, понимание которых облегчит понимание языка в целом:

- Выражения
- [[Объекты в Javascript]]
- Функции

## Выражения

Title

Любое выражение всегда возвращает значение

Выражение - это некоторый код, который после своего выполнения возвращает какое-либо значение.  
Например:

```js
5 + 3
8
```

Другой пример:

```js
let a
a = True
```

В данном случае:

- `let a` - это инструкция. Мы как бы "говорим" интерпретатору JS, что мы объявляем переменную
- `a = True` - это выражение, потому что оно возвращает значение.

Выражениям помогают операторы вроде `-`, `+` и так далее, как в примере выше

## Переменные

Переменные - это некие контейнеры, которые хранят в себе определенные значения. Переменные есть, как мне кажется, вообще во всех языках программирования.  
Именование переменных:

- PascalCase
    - используется для именования классов и типов
- camelCase
    - используется во всех остальных случаях
- CONSTANT  
    - используется для объявления чего-то постоянного вроде `DB_PASSWORD`  
    - эти значения известны еще до запуска приложения  
    Переменные объявляются сейчас с помощью `let` и `const`. Раньше еще использовался `var`, но сейчас это считается уже легаси. Переменные можно:
- Объявить переменную

```js
let a
```

- Присвоить переменной значение

```js
a = True
```

- Объявить и присвоить

```js
let a = True
```

Разница между `let` и `const` видна из названия последнего: это обычная переменная, значение которой можно переопределить дальше в коде и константа, значение которой, при попытке переопределить, даст ошибку вида `TypeError`

### Типы переменных

Title

Тип переменной определяется значением, которое для нее определяется

Так, например:

```js
const a = 10
const b = "name"
```

Переменная `a` будет типом `number`, потому что внутри нее лежит соответствующее значение.  
Переменная `b`, соответственно, будет иметь тип `string`

## Типы

### Примитивные типы

- string
- boolean
    - true/false
- number
- null
    - используем в том случае, когда мы хотим явно указать, что у какой-то переменной значение отсутствует
- undefined  
    - это мы можем встретить в том случае, если не объявили значение для переменной  
    разница между `null` и `undefined` в том, что первый мы определяем **явно и самостоятельно**, а последний будет определен автоматически в том случае, если мы не указали значение для переменной
- symbol  
    Суть хранения данных такого типа в том, что значения сразу хранятся в переменных, словно ложка, которую мы положили в ящик с другими приборами

### Ссылочные типы

Это [объекты](app://obsidian.md/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B%20%D0%B2%20Javascript). Поэтому тут хранение несколько отличается от примитивных типов.

Данные у таких типов хранятся не в самой переменной, а в памяти компьютера. И поэтому когда нам нужно "достать" значение такой переменной, то мы открываем снова ящик с приборами (который я упоминал выше), но там будет лежать уже не сама ложка, как это было с примитивным типом, а записка, на которой будет указано, где именно искать наши значения.

Схематически это выглядит так:  
	![[Pasted image 20250209143903.png]] 
Например:

```js
let objectA = {
  b: 10,
  c: 5,
};
```

В данном случае у нас есть объект `objectA`. Внутри него хранятся пары `ключ:значение`.

Хорошо, а теперь создадим копию нашей переменной и изменим одно из свойств:

```js
let objectA = {
  b: 10,
  c: 5,
};

let copyOfObjectA = objectA;

console.log((copyOfObjectA.b = 100)); // 100
console.log(objectA.b); // 100
```

В данном случае видно, что я изменил свойство `objectA.b` на `100` вместо `10` и теперь если мы обращаемся к оригиналу `objectA.b`, то мы получим также `100`, потому что в нашей ячейке памяти изменилось значение (см рисунок выше)

Помимо **изменения** первоначальных значений мы можем также и добавлять новые:

```js
let objectA = {
  b: 10,
  a: 5,
};

let copyOfObjectA = objectA;

console.log((copyOfObjectA.b = 100)); // 100
console.log(objectA.b); // 100

console.log((copyOfObjectA.c = "Data")); // Data
console.log(objectA.c); // Data
```

По итогу у нас из вот такого первоначального вида объекта:

```js
objectA {
	b: 10,
	a: 5
};
```

Получился вот такой:

```js
objectA {
	b: 100,
	a: 5,
	c: "Data"
};
```

## Динамическая типизация

В языках со статической типизацией (вроде Go) необходимо явно указать, какой тип данных мы будем использовать: строка, число и так далее.  
В JS же этого не требуется и более того - динамическая типизация позволяет изменять содержимое переменных по ходу кода:

```js
let A = "abc" // A = "abc"
let A = 123  //  A = "123"
```

С одной стороны это удобно - не нужно явно определять тип переменной, но с другой - в большой программе можно банально забыть о том, что ранее у той или иной переменной значение уже определено.  
И решением этой проблемы является использование `const`